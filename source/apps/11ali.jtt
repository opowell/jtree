app.description = 'Players vote in groups, votes are implemented once the result has been repeated a certain number of times.';

app.numRounds = 10; // Number of times to re-match participants into new groups.
app.groupSize   = 3; // Number of players in a voting group.

app.stageWaitToStart = true; // wait for all players in group before starting a stage
app.stageWaitToEnd = true; // wait for all players in group before ending a stage
// app.groupSizes = [3, 3, 3, 5, 5, 5];
// app.stoppingRule = ['matching', 'matching', 'matching', 'random', 'random', 'random'];
app.stoppingRuleRandom_StopProb = 0.3;
app.stoppingRuleMatching_NumRequiredMatches = 1; // Number of matches required in a row to trigger an outcome.
app.stoppingRuleFixed_Number = 3;
app.maxNumVotesPerRound = 50; // How many votes a single group can actually have.

app.stoppingRule = 'fixed'; // or 'matching', or 'random'

// Calculated variables
app.numPeriods  = app.numRounds * app.maxNumVotesPerRound;

// Keep track of matching.
app.prevMatchingArray = null;
app.getGroupIdsForPeriod = function(period) {
    
    // If any group has not yet finished, continue current round.
    let rematch = true;
    if (period.id > 1) {
        let prevPeriod = period.app.periods[period.id-2];
        for (let g in prevPeriod.groups) {
            if (!prevPeriod.groups[g].finished) {
                rematch = false;
                break;
            }
        }
    }
    if (!rematch) {
        return app.prevMatchingArray;
    }

    // New round, create new matching.
    let parts = period.session().participants;
    let partIds = Object.keys(parts); // P1, P2, ...
    partIds = Utils.shuffle(partIds); // randomly shuffled version of above.
    let numGroups = partIds.length / app.groupSize;

    // Split into subarrays, one for each group. Ex:
    // [
    //   [P1, P5, P4]
    //   [P2, P6, P3]
    //   ...
    // ]
    let out = [];
    for (let i=0; i<numGroups; i++) {
        out.push(partIds.splice(0, app.groupSize));
    }

    // Increment "round" variable
    console.log('incrementing');
    for (let i in parts) {
        if (parts[i].round == null) {
            parts[i].round = 0;
        }
        parts[i].round++;
        parts[i].numMatches = 0;
        parts[i].numVotes = 0;
        parts[i].payoff = false;
        parts[i].groupFinished = false;
        parts[i].history = [];
    }

    // Track matching.
    app.prevMatchingArray = out;

    // Return
    return out;
}

app.payoffs = [
    [ // P1
        [5, 4],
        [3, 2]
    ],
    [ // P2
        [3, 2],
        [4, 5]
    ],
    [ // P3
        [2, 4],
        [5, 3]
    ],
]

app.getPayoff = function(idInGroup, R0, C0) {
    return app.payoffs[idInGroup-1][R0 ? 0 : 1][C0 ? 0 : 1];
}

// Wait for all players before starting each period.
app.participantBeginPeriod = function(participant) {
    var prd = participant.periodIndex;
    participant.emit('participantSetPeriodIndex', {periodIndex: participant.periodIndex});

    var period = this.getPeriod(prd);
    if (period === undefined) {
        return false;
    }

    // If any participant is not in period yet, stop and wait.
    let parts = participant.session.participants;
    for (let p in parts) {
        if (parts[p].periodIndex > prd) {
            parts[p].periodIndex = prd;
        }
        // console.log(p + ': ' + parts[p].periodIndex);
    }
    for (let p in parts) {
        if (parts[p].periodIndex < participant.periodIndex) {
            return;
        }
    }

    // All ready, start the period.
    for (let p in parts) {
        period.participantBegin(parts[p]);
    }

}

var decideStage = app.newStage('decide');

// Track previous group activity, if any.
decideStage.groupStart = function(group) {
    console.log('starting decide for group ' + group.id);
    let p0 = group.players[0].participant;
    group.finished = p0.groupFinished;
    group.prevOutcomeR0 = p0.prevOutcomeR0;
    group.prevOutcomeC0 = p0.prevOutcomeC0;
    group.round = p0.round;
    group.numVotes = p0.numVotes + 1;
    group.numMatches = p0.numMatches;
    group.justFinished = false;
    group.history = p0.history;
}

decideStage.playerStart = function(player) {
    player.payoffTopLeft = player.app().getPayoff(player.idInGroup, true, true);
    player.payoffTopRight = player.app().getPayoff(player.idInGroup, true, false);
    player.payoffBottomLeft = player.app().getPayoff(player.idInGroup, false, true);
    player.payoffBottomRight = player.app().getPayoff(player.idInGroup, false, false);
}

// Only play this stage if the group does not have a payoff yet.
decideStage.canPlayerParticipate = function(player) {
    return !player.group.finished && player.group.round <= app.numRounds; 
}

decideStage.activeScreen = `
<div style='display: flex; align-items: center; flex-direction: column;'>
    <p>DECISION</p>
    <p>Group: {{group.id}}</p>
    <p>Round: {{group.round}} / {{app.numRounds}}</p>

    <p v-if='app.stoppingRule === "matching"'>Vote: {{group.numVotes}} / max. {{app.maxNumVotesPerRound}}</p>
    <p v-if='app.stoppingRule === "matching"'>Matches: {{group.numMatches}} / {{app.stoppingRuleMatching_NumRequiredMatches}}</p>

    <p v-if='app.stoppingRule === "fixed"'>Vote: {{group.numVotes}} (vote #{{app.stoppingRuleFixed_Number}} will be selected)</p>

    <p v-if='app.stoppingRule === "random"'>Vote: {{group.numVotes}} (stop with prob. {{app.stoppingRuleRandom_StopProb}})</p>
</div>    

    <style>

    #jtree > :first-child {
        display: none;
    }

    .main > span {
        border: 1px solid #888;
        padding: 2rem;
        margin: 1rem;
        flex: 0 1 auto;
    }

    table.outcome td {
        background-color: green;
    }

    .selected {
        background-color: red !important;
    }

    .choiceTable td {
        border: 1px solid #888;
    }

    table td {
        width: 45px;
        height: 45px;
        text-align: center;
    }

    body {
        max-width: unset;
    }

    </style>

    <div class='main' style='display: flex; align-items: flex-start;'>
        <span>
<table class='choiceTable'>
<tr>
    <th></th>
    <th>Left</th>
    <th>Right</th>
</tr>
<tr>
    <th>Top</th>
    <td>{{player.payoffTopLeft}}</td>
    <td>{{player.payoffTopRight}}</td>
</tr>
<tr>
    <th>Bottom</th>
    <td>{{player.payoffBottomLeft}}</td>
    <td>{{player.payoffBottomRight}}</td>
</tr>
</table>
<p>Your payoffs based on voting outcomes.</p>
        </span>
        <span>
    <p>Your vote for the column:</p>
    <p>
        <input name='player.colChoice' type='radio' required value='colLeft' id='colLeft'>
        <label for='colLeft'>Left</label>
        <input name='player.colChoice' type='radio' required value='colRight' id='colRight'>
        <label for='colRight'>Right</label>
    </p>
    <p>Your vote for the row:</p>
    <p>
        <input name='player.rowChoice' type='radio' required value='rowTop' id='rowTop'>
        <label for='rowTop'>Top</label>
        <br>
        <input name='player.rowChoice' type='radio' required value='rowBottom' id='rowBottom'>
        <label for='rowBottom'>Bottom</label>
    </p>
    <button>Make choice</button>
        </span>
        <span>
    <p>
        <b>Previous outcomes</b><br>
        <div v-for='(outcome, index) in group.history'>
            {{index+1}}. {{outcome.R0 ? 'Top' : 'Bottom'}}, {{outcome.C0 ? 'Left' : 'Right'}}
        </div>
        <b>Previous outcomes</b><br>
        <div v-for='(outcome, index) in group.history'>
            <br>
            {{index+1}}. <table class='outcome'>
                <tr>
                    <td :class='(outcome.R0 && outcome.C0) ? "selected" : ""'></td>
                    <td :class='(outcome.R0 && !outcome.C0) ? "selected" : ""'></td>
                </tr>
                <tr>
                    <td :class='(!outcome.R0 && outcome.C0) ? "selected" : ""'></td>
                    <td :class='(!outcome.R0 && !outcome.C0) ? "selected" : ""'></td>
                </tr>
            </table>
        </div>
    </p>
        </span>
    </div>

    <style>
    .playerChoice {
        color: red;
        font-size: 14pt;
    }
    </style>
`;


// Code deleted from screen
/* <p>Make a choice.</p>
<select name='player.choice' required style='color: red; font-size: 14pt;' class='playerChoice'>
    <option value='a'>00</option>
    <option value='b'>01</option>
    <option value='c'>10</option>
    <option value='d'>11</option>
</select> */

var resultsStage = app.newStage('results');
// Only play this stage if the group does not have a payoff yet.
resultsStage.canPlayerParticipate = function(player) {
    return (!player.group.finished || player.group.justFinished) && 
        player.group.round <= app.numRounds; 
}
resultsStage.groupStart = function(group) {

    if (group.finished) {
        return;
    }

    // Groups only last a single period, use participant of first player to store group history
    let p0 = group.players[0].participant;

    // Count number of times group has voted.
    if (p0.numVotes == null) {
        p0.numVotes = 0;
    }
    p0.numVotes++;
    group.numVotes = p0.numVotes;

    // Count votes.
    group.voteR0 = 0; // top
    group.voteR1 = 0; // bottom
    group.voteC0 = 0; // left
    group.voteC1 = 0; // right
    for (let p in group.players) {
        let player = group.players[p];
        if (player.rowChoice === 'rowTop') {
            group.voteR0++;
        }
        if (player.rowChoice === 'rowBottom') {
            group.voteR1++;
        }
        if (player.colChoice === 'colLeft') {
            group.voteC0++;
        }
        if (player.colChoice === 'colRight') {
            group.voteC1++;
        }
        // switch (group.players[p].choice) {
        //     case 'a':
        //         group.voteR0++;
        //         group.voteC0++;
        //         break;
        //     case 'b':
        //         group.voteR0++;
        //         group.voteC1++;
        //         break;
        //     case 'c':
        //         group.voteR1++;
        //         group.voteC0++;
        //         break;
        //     case 'd':
        //         group.voteR1++;
        //         group.voteC1++;
        //         break;
        // }
    }

    // Determine outcome.
    group.outcomeR0 = group.voteR0 > group.voteR1;
    group.outcomeC0 = group.voteC0 > group.voteC1;
    
    // Compare with previous outcome.
    group.matchesLastRound = 
        group.outcomeR0 === group.prevOutcomeR0 &&
        group.outcomeC0 === group.prevOutcomeC0
    ;

    // Calculate number of consecutive matches
    if (group.matchesLastRound) {
        // Initialize variable, if necessary.
        if (p0.numMatches == null) {
            p0.numMatches = 0;
        }
        // Increment counter.
        group.numMatches = p0.numMatches + 1;
    } 
    // No match, reset counter.
    else {
        group.numMatches = 0;
    }

    let finishRound = false;
    switch (group.period.app.stoppingRule) {
        case 'fixed':
            finishRound = group.numVotes >= app.stoppingRuleFixed_Number;
            break;
        case 'random':
            group.randomDraw = Math.random();
            finishRound = group.randomDraw < app.stoppingRuleRandom_StopProb;
            break;
        case 'matching':
            finishRound = group.numMatches >= app.stoppingRuleMatching_NumRequiredMatches;
            break;
    }

    // If sufficient number of matches, calculate payoffs and signal for rematching.
    if (finishRound) {
        group.payoff = true;
        group.justFinished = true;
        group.finished = true;
        for (let p in group.players) {
            group.players[p].points = app.getPayoff(group.players[p].idInGroup, group.outcomeR0, group.outcomeC0);
        }
    }

    // Record values to carry over to next period.
    p0.prevOutcomeR0 = group.outcomeR0;
    p0.prevOutcomeC0 = group.outcomeC0;
    p0.numMatches = group.numMatches;
    p0.numVotes = group.numVotes;
    p0.payoff = group.payoff;
    p0.round = group.round;
    p0.groupFinished = group.finished;

    // Store history
    group.history.push({R0: group.outcomeR0, C0: group.outcomeC0});
    p0.history = group.history;
}
resultsStage.activeScreen = `
    <p>RESULTS</p>
    <p>Group: {{group.id}}</p>
    <p>Round: {{group.round}} / {{app.numRounds}}</p>

    <p v-if='app.stoppingRule === "matching"'>Vote: {{group.numVotes}} / max. {{app.maxNumVotesPerRound}}</p>
    <p v-if='app.stoppingRule === "matching"'>Matches: {{group.numMatches}} / {{app.stoppingRuleMatching_NumRequiredMatches}}</p>

    <p v-if='app.stoppingRule === "fixed"'>Vote: {{group.numVotes}} (vote #{{app.stoppingRuleFixed_Number}} will be selected)</p>

    <p v-if='app.stoppingRule === "random"'>Vote: {{group.numVotes}} (stop with prob. {{app.stoppingRuleRandom_StopProb}})</p>

    <p>Outcome of R0: {{group.outcomeR0}}</p>
    <p>Outcome of C0: {{group.outcomeC0}}</p>
    
    <p v-if='app.stoppingRule === "random"'>
        The randomly chosen value was {{group.randomDraw | round(2) }}, which IS <span v-if='group.randomDraw > app.stoppingRuleRandom_StopProb'>NOT</span> smaller than the stopping probability ({{app.stoppingRuleRandom_StopProb}}).
    </p>

    <p v-if='app.stoppingRule === "fixed"'>
        This vote IS <span v-if='group.numVotes < app.stoppingRuleFixed_Number'>NOT</span> the last vote.
    </p>
    
    <p v-if='app.stoppingRule === "matching" && group.numMatches >= app.stoppingRuleMatching_NumRequiredMatches'>
        Enough matches.
    </p>

    <p v-if='app.stoppingRule === "matching" && group.numMatches < app.stoppingRuleMatching_NumRequiredMatches'>
        Not enough matches.
    </p>

    <p v-if='group.payoff == true'>
        Your payoff in this voting period is {{player.points}} E$. The next vote will start once all other groups have finished this round.
    </p>
    <p v-if='group.payoff != true'>
        The round will continue.
    </p>
`;

let finalStage = app.newStage('final');
finalStage.activeScreen = `
    Your points from all rounds: {{participant.numPoints}}.
`;
finalStage.addOKButtonIfNone = false;
finalStage.canPlayerParticipate = function(player) {
    return player.group.round > app.numRounds;
}